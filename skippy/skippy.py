#!/usr/bin/env python
# -*- coding:utf-8 -*- 


##############################################################################
## license :
##============================================================================
##
## File :        Skippy.py
## 
## Project :     SCPI
##
## This file is part of Tango device class.
## 
## Tango is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## Tango is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with Tango.  If not, see <http://www.gnu.org/licenses/>.
## 
##
## $Author :      sblanch$
##
## $Revision :    $
##
## $Date :        $
##
## $HeadUrl :     $
##============================================================================
##            This file is generated by POGO
##    (Program Obviously used to Generate tango Object)
##
##        (c) - Software Engineering Group - ESRF
##############################################################################

"""Standard Commands for Programmable Instruments (SCPI) DeviceServer """

__all__ = ["Skippy", "SkippyClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(Skippy.additionnal_import) ENABLED START -----#
import communicator
import copy
import instructionSet
import numpy
import socket
import struct
import threading
import time
import traceback
from types import StringType
from version import version

MINIMUM_RECOVERY_DELAY = 3.0
DEFAULT_RECOVERY_DELAY = 600.0
DEFAULT_ERRORS_THRESHOLD = 1
RECONNECT_THREAD_DELETE_TRIES = 3
#----- PROTECTED REGION END -----#  //  Skippy.additionnal_import

## Device States Description
## OFF : No connection stablished with the instrument.
## ON : Connection stablished with the instrument.
## RUNNING : Connection stablished and active monitoring.
## ALARM : Reported errors from the instrument.
## FAULT : Communication error with the instrument.
## INIT : Initialization stage.
## STANDBY : 

class Skippy (PyTango.Device_4Impl):

    #--------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(Skippy.global_variables) ENABLED START -----#

    ######
    # section to resolve instrument property ---
    def __buildInstrumentObj(self):
        '''Builder of object that will manage the communications with the
           specified instrument in the properties.
           To have this object made only means that this device has recognized
           if the communications will be made using socket connection or using
           the VISA protocol provided by a lower level tango device.
           The expected result of this method is to have the skippy tango
           device in OFF state.
        '''
        self.info_stream("In __buildInstrumentObj()")
        try:
            self._instrument = None
            if self.SerialTimeout == -1:
                timeout = None
            else:
                timeout = self.SerialTimeout
            extra_arguments = {'baudrate': self.SerialBaudrate,
                               'bytesize': self.SerialBytesize,
                               'parity': self.SerialParity,
                               'stopbits': self.SerialStopbits,
                               'timeout': timeout,
                               'xonxoff': self.SerialXonXoff}
            terminator = self.TxTerminator
            self._instrument = communicator.buildCommunicator(self.Instrument,
                                                              self.Port,
                                                              self,
                                                              extra_arguments,
                                                              terminator)
        except SyntaxError as e:
            self.error_stream("Error in the instrument name: %s" % (e))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("%s: review the 'instrument' property" % (e))
            return False
        except Exception as e:
            self.error_stream("Generic exception: %s" % (e))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("initialisation exception: %s" % (e))
            return False
        self.change_state(PyTango.DevState.OFF)
        self.rebuildStatus()
        return True

    def __connectInstrumentObj(self, tries=4):
        '''With this method a communication channel is opened to the instrument
           and the identification string is requested to it.
        '''
        if not hasattr(self, '_instrument') or self._instrument is None:
            self.error_stream("In __connectInstrumentObj(): instrument "
                              "object not build yet")
            return False
        try:
            self._instrument.connect()
            self._idn = ''
            for i in range(1, tries+1):
                self._idn = self._instrument.ask("*IDN?", waittimefactor=i)
                if len(self._idn) > 0:
                    break
                if self._reconnectAwaker.isSet():
                    self.info_stream("Abort reconnection to the instrument")
                    return False
                self.warn_stream("In __connectInstrumentObj() no answer to the"
                                 " identification request (try %d)" % (i))
                time.sleep(communicator.TIME_BETWEEN_SENDANDRECEIVE*10)
            if len(self._idn) == 0:
                self.error_stream("In __connectInstrumentObj() Cannot identify"
                                  " the instrument after %d tries" % (i))
                return False
            self.info_stream("In __connectInstrumentObj() instrument "
                             "identification: %s" % (self._idn))
        except Exception as e:
            self.error_stream("In __connectInstrumentObj() Cannot connect "
                              "to the instrument due to: %s" % (e))
            traceback.print_exc()
            return False
        else:
            self.info_stream("In __connectInstrumentObj() Connected to "
                             "the instrument and identified as: %r"
                             % (self._idn))
            return True

    def __reconnectInstrumentObj(self):
        '''This method contains a procedure to reconnect to the instrument, if
           it is possible. It uses the state DISABLE to report that it is
           temporally out of service and automatically trying to recover.
           If the connection can be restablished the state goes to ON or
           RUNNING depending on the monitoring procedure.
           Else, in case the communication cannot be restablished by itself,
           then the state changes to FAULT to report the malfunction.
        '''
        self.info_stream("In __reconnectInstrumentObj()")
        if not hasattr(self, '_instrument') or self._instrument is None:
            self.error_stream("In __reconnectInstrumentObj(): instrument "
                              "object not build yet")
            return False
        try:
            self._instrument.disconnect()
            self.change_state(PyTango.DevState.DISABLE)
            self.rebuildStatus()
        except Exception as e:
            self.error_stream("In __reconnectInstrumentObj(): disconnect "
                              "exception: %s" % (e))
            self.change_state(PyTango.DevState.FAULT)
            self.rebuildStatus()
            return False
        if self.__buildInstrumentObj():
            if self.Off():
                self.warn_stream("In __reconnectInstrumentObj() "
                                 "delay reconnection by %6.3f seconds"
                                 % (self._recoveryDelay))
                time.sleep(self._recoveryDelay)
                if self.Standby() and self.On():
                    if self.AutoStart and self.Start():
                        print("....")
                        self.info_stream("In __reconnectInstrumentObj(): "
                                         "reconnected and started.")
                        self._lastRecovery = time.time()
                        return True
                    else:
                        print("...,")
                        self.info_stream("In __reconnectInstrumentObj(): "
                                         "reconnection done.")
                        self._lastRecovery = time.time()
                        return True
        self.change_state(PyTango.DevState.DISABLE)
        self.rebuildStatus()
        self.error_stream("In __reconnectInstrumentObj(): "
                          "Cannot rebuild the InstrumentObj.")
        return False

    def __reconnectProcedure(self):
        '''The procedure of reconnect, because it takes time, is executed by
           a separeated thread. This avoids timeout issues from the thread
           that comes from the read_attribute() call.
        '''
        try:
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Fatal error and communications lost with "
                              "the instrument!", important=True)
            #self.warn_stream("Starting a reconnect procedure.")
            #if self._reconnectThread is not None and \
            #        self._reconnectThread.isAlive():
            #    self.warn_stream("Past reconnection thread is still alive...")
            #    self._reconnectAwaker.set()
            #    self._reconnectThread.join(1)
            #    while self._reconnectThread.isAlive():
            #        self.warn_stream("Waiting the past reconnection thread "
            #                         "to finish")
            #        self._reconnectThread.join(1)
            #    self.info_stream("Past reconnection thread finish")
            #    # how to check if a the past reconnection was active and has
            #    # already fixed the issue?
            #    if self._instrument.isConnected():
            #        self.info_stream("Communication recovered by "
            #                         "past reconnection thread")
            #        return
            #if self._reconnectThread is None:
            #    self.info_stream("Creating a reconnection thread")
            #    self._reconnectThread = \
            #        threading.Thread(target=self.__doReconnect,
            #                         name="reconnect")
            #    self._reconnectThread.setDaemon(True)
            #if not self._reconnectThread.isAlive():
            #    self.info_stream("Launching the reconnection thread")
            #    self._reconnectThread.start()
        except Exception as e:
            self.error_stream("Reconnect procedure cannot be started: %s"
                              % (e))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Fatal error and communications lost with "
                              "the instrument!", important=True)

    def __doReconnect(self):
        '''To reconnect to the instrument, and this often happens due to the
           drowning in the instrument response, after disconnect delay the
           reconnection following the algorithm:
           1.- if more than N errors during the last M seconds:
               then delay the recovery by S seconds.
           2.- if last delayed recovery comes from less than R seconds:
               then double the S time.
        '''
        try:
            self.info_stream("Reconnection thread started")
            now = time.time()
            # 1.- if more than N errors during the last M seconds:
            #     then delay the recovery by S seconds.
            if self.__communicationErrors(now, self._lastMSeconds) > \
                    self._lastNErrorsThreshold:
                self.info_stream("In __doReconnect() found more than "
                                 "%d errors" % (self._lastNErrorsThreshold))
                # 2.- if last delayed recovery comes from less than R seconds:
                #     then double the S time.
                if self._lastRecovery is not None and \
                        now-self._lastRecovery < \
                        self._recoverThreshold + self._recoveryDelay:
                    self.warn_stream("In __doReconnect() doubling the "
                                     "time to recover because the error "
                                     "happened less than %6.3f seconds after "
                                     "the previous recover delay of %6.3f "
                                     "seconds" % (self._recoverThreshold,
                                                  self._recoveryDelay))
                    if self._recoveryDelay <= self._lastMSeconds:
                        # maximum delay
                        self._recoveryDelay = self._recoveryDelay * 2
                elif self._recoveryDelay > MINIMUM_RECOVERY_DELAY:
                    self._recoveryDelay = self._recoveryDelay / 2
                self.warn_stream("In __doReconnect() delay reconnection "
                                 "by %6.3f seconds" % (self._recoveryDelay))
                time.sleep(self._recoveryDelay)
            self.__appendToCommunicationLost(now)
            reconnected = self.__reconnectLoop(tries=5)
            if reconnected:
                return True
            retriesMade = 5
            self.info_stream("Could not reconnect, check the instrument")
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Reconnection procedure not possible",
                              important=True)
            reconnected = self.__reconnectLoop(tries=retriesMade+10,
                                               fixTime2retry=60,
                                               starttry=retriesMade+1)
            retriesMade += 10
            if reconnected:
                return True
            self.info_stream("Extend the time for reconnect tries")
            reconnected = self.__reconnectLoop(tries=retriesMade+12,
                                               fixTime2retry=600,
                                               starttry=retriesMade+1)
            if reconnected:
                return True
            self.error_stream("In __doReconnect() no more retries")
            return False
        except PyTango.DevFailed as e:
            try:
                self.error_stream("In __doReconnect() DevFailed Exception: %s"
                                  % (e))
                self.change_state(PyTango.DevState.FAULT)
                self.cleanAllImportantLogs()
                self.addStatusMsg("Reconnection procedure not possible",
                                  important=True)
                return False
            except:
                traceback.print_exc()
        except Exception as e:
            try:
                self.error_stream("In __doReconnect() Exception: %s" % (e))
                self.change_state(PyTango.DevState.FAULT)
                self.cleanAllImportantLogs()
                self.addStatusMsg("Reconnection procedure not possible",
                                  important=True)
                return False
            except:  # !!we've seen an exception in this lines
                traceback.print_exc()
        self.info_stream("Reconnection procedure End")

    def __reconnectLoop(self, tries, fixTime2retry=None, starttry=None):
        i = starttry or 1
        self.debug_stream("Start a reconnection loop between %d and %d"
                          % (i, tries))
        if fixTime2retry is not None:
            time2retry = fixTime2retry
            self.info_stream("Reconnection will be tried every %d seconds"
                             % time2retry)
        while i <= tries:
            if self.__reconnectInstrumentObj():
                self.info_stream("Reconnection work in the %d retry" % (i))
                return True
            if fixTime2retry is None:
                time2retry = self._recoveryDelay * i
            msg = "Reconnection try didn't work (%dth), "\
                "retry in %6.3f seconds" % (i, time2retry)
            self.warn_stream(msg)
            self.addStatusMsg(msg)
            self._reconnectAwaker.wait(time2retry)
            if self._reconnectAwaker.isSet():
                self.info_stream("Abort reconnection")
                return False
            i += 1
        return False

    def __communicationErrors(self, now, mseconds):
        '''This collects information about transitory communication errors.
        '''
        nErrors = 0
        for each in self._commLost:
            if each <= now-mseconds:
                nErrors += 1
            else:
                self.info_stream("In __communicationErrors(%6.3f) remove "
                                 "%6.3f from the list of communication "
                                 "errors because it is too old."
                                 % (mseconds, each))
                self._commLost.pop(self._commLost.index(each))
        self.info_stream("In __communicationErrors(%6.3f) found %d errors"
                         % (mseconds, nErrors))
        return nErrors

    def __appendToCommunicationLost(self, now):
        self._commLost.append(now)

    def prepareMutex(self):
        '''If needed create all the mutex requested (first execution) and if
           any already exist free all the threads waiting in order to clean up
           them (like a restart).
        '''
        if not hasattr(self, '_stateMutex'):
            self.debug_stream("preparing stateMutex")
            self._stateMutex = threading.Semaphore()
        else:
            while not self._stateMutex.acquire(False):
                self.debug_stream("releasing stateMutex")
                self._stateMutex.release()

    def stateMutex(decoratedMethod):
        def magic(self, methodVble):
            if hasattr(self, '_stateMutex'):
                self.debug_stream("stateMutex() request to acquire "
                                  "by thread %r"
                                  % (threading.currentThread().name))
                self._stateMutex.acquire()
                self.debug_stream("stateMutex() acquired by %r thread"
                                  % (threading.currentThread().name))
            try:
                decoratedMethod(self, methodVble)
            except Exception as e:
                self.error_stream("In StateMutex() thread %r exception: %s"
                                  % (threading.currentThread().name, e))
            if hasattr(self, '_stateMutex'):
                self._stateMutex.release()
                self.debug_stream("stateMutex() thread %r release"
                                  % (threading.currentThread().name))
        return magic

    # done section to resolve instrument property ---
    ######

    ######
    # dynamic attributes builder section ---
    def __builder(self):
        try:
            if hasattr(self, '_idn') and self._idn not in [None, ""]:
                self._builder = instructionSet.identifier(self._idn, self)
            else:
                raise Exception("*IDN? not available")
        except Exception as e:
            if hasattr(self, '_idn'):
                msg = "identification error: %s (*IDN?:%r)" % (e, self._idn)
            else:
                msg = "identification error: %s" % (e)
            self.error_stream("%s %s" % (self.get_name(), msg))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg(msg)
            return False
        else:
            return True

    def __unbuilder(self):
        try:
            self._builder.remove_alldynAttrs()
            return True
        except Exception as e:
            self.error_stream("Exception removing dynattributes: %s" % (e))
            return False

    def __read_attr_procedure(self, data, fromMonitor=False):
        '''This method is the read_attr_hardware, but we had to distinguish
           between monitoring calls for events than the direct requests to the
           device. This is because, direct requests of monitored attributes
           should not do a real hardware read.
           TODO: as all the readers (external or any of the monitors) will call
           this method, here is the place to implement the priorities.
        '''
        if self.get_state() in [PyTango.DevState.FAULT]:
            self.debug_stream("Avoid read procedure in %s state"
                              % (self.get_state()))
            return
        self.debug_stream("In __read_attr_procedure(%r)" % (data))
        try:
            multiattr = self.get_device_attr()
            scalarList, spectrumList, imageList = \
                self.__filterAttributes(multiattr, data, fromMonitor)
            if not len(scalarList) == 0:
                indexes, queries = \
                    self.__preHardwareRead(scalarList,
                                           self.attr_QueryWindow_read)
                answers = []
                for query in queries:
                    answer = self.__hardwareRead(query)
                    answers.append(answer)
                msg = ""
                for answer in answers:
                    if answer is None:
                        self.error_stream("In __read_attr_procedure() "
                                          "Uou, we've got a null answer!")
                        return
                    elif len(answer) > 100:
                        msg = ''.join([msg, "%r(...)%r"
                                       % (answer[:25],
                                          answer[len(answer)-25:])])
                    else:
                        msg = ''.join([msg, "%r" % (answer)])
                self.debug_stream("In __read_attr_procedure() scalar answers:"
                                  " %r" % (msg))
                self.__postHardwareScalarRead(indexes, answers)
            if not len(spectrumList) == 0:
                indexes, queries = self.__preHardwareRead(spectrumList, 1)
                answers = []
                for query in queries:
                    answer = self.__hardwareRead(query)
                    if answer is not None:
                        answers.append(answer)
                self.debug_stream("In __read_attr_procedure() spectrum "
                                  "answers number: %s" % (len(answers)))
                self.__postHardwareSpectrumRead(indexes, answers)
            if not len(imageList) == 0:
                self.error_stream("Excluding 2 dimensional attributes")
        except PyTango.DevFailed as e:
            self.error_stream("In __read_attr_procedure() Exception: %s" % (e))
            traceback.print_exc()
        except Exception as e:
            self.error_stream("In __read_attr_procedure() Exception: %s" % (e))

    def __filterAttributes(self, multiattr, data, fromMonitor):
        '''Avoid hardware readings of:
           - attributes that are internals to the device
           - attributes that reading is recent
           - attributes where its channel/function manager say closed
        '''
        try:
            t = time.time()
            delta_t = self.attr_TimeStampsThreshold_read
            scalar = []
            spectrum = []
            image = []
            for attrIndex in data:
                attrObj = multiattr.get_attr_by_ind(attrIndex)
                attrName = attrObj.get_name()
                if attrName not in self.attributes:
                        self.debug_stream("In __filterAttributes() "
                                          "excluding %s: is not a hw attr."
                                          % (attrName))
                else:
                    # filter attributes depending if they are monitored
                    if self.get_state() == PyTango.DevState.RUNNING and \
                            (fromMonitor and
                             attrIndex not in self._monitoredAttributeIds) or\
                            (not fromMonitor and
                             attrIndex in self._monitoredAttributeIds):
                        self.debug_stream("In __filterAttributes() excluding "
                                          "%s because the monitoring "
                                          "dependency" % (attrName))
                    else:
                        # discard if the channel or function is not open
                        attrName = self.__checkChannelManager(attrName)
                        if attrName is not None:
                            try:
                                t_a = self.attributes[attrName].timestamp
                                attrObj = multiattr.get_attr_by_name(attrName)
                                if attrIndex not in \
                                        self._monitoredAttributeIds and \
                                        t_a is not None and t - t_a < delta_t:
                                    self.debug_stream("In __filterAttributes"
                                                      "() excluding %s: "
                                                      "t < delta_t"
                                                      % (attrName))
                                else:
                                    if attrObj.get_data_format() == \
                                            PyTango.AttrDataFormat.SCALAR:
                                        scalar.append(attrName)
                                    elif attrObj.get_data_format() == \
                                            PyTango.AttrDataFormat.SPECTRUM:
                                        spectrum.append(attrName)
                                        # when an spectrum are required, some
                                        # reference attributes will be needed
                                        if 'WaveformDataFormat' in \
                                                self.attributes:
                                            scalar.append('WaveformDataFormat')
                                        if 'WaveformOrigin' in self.attributes:
                                            scalar.append('WaveformOrigin')
                                        if 'WaveformIncrement' in \
                                                self.attributes:
                                            scalar.append('WaveformIncrement')
                                    elif attrObj.get_data_format() == \
                                            PyTango.AttrDataFormat.IMAGE:
                                        image.append(attrName)
                                    else:
                                        self.error_stream("In "
                                                          "__filterAttributes"
                                                          "() unknown data "
                                                          "format for "
                                                          "attribute %s"
                                                          % (attrName))
                            except Exception as e:
                                self.error_stream("In __filterAttributes() "
                                                  "cannot manage the filter "
                                                  "for the attribute %s: %s"
                                                  % (attrName, e))
            self.debug_stream("In __filterAttributes():\n\tscalar list:\t%s;"
                              "\n\tspectrum list:\t%s;\n\timage list:\t%s;"
                              % (scalar, spectrum, image))
            # Remove repeated attributes
            for attr in scalar:
                while scalar.count(attr) > 1:
                    scalar.pop(scalar.index(attr))
            for attr in spectrum:
                while spectrum.count(attr) > 1:
                    spectrum.pop(spectrum.index(attr))
            for attr in image:
                while image.count(attr) > 1:
                    image.pop(image.index(attr))
            return scalar, spectrum, image
        except Exception as e:
            self.error_stream("In __filterAttributes(%s) Exception: %s"
                              % (data, e))
            traceback.print_exc()
            return [], [], []
            # FIXME: does this return the same list object 3 times?
            #        could it return 3 Nones?

    def __checkChannelManager(self, attrName):
        if attrName[-3:-1] in ['Ch', 'Fn']:
            if attrName[-3:] in self.attributesFlags:
                managerName = self.attributesFlags[attrName[-3:]]
                managerValue = self.attributes[managerName].lastReadValue
                if managerValue is None:
                    return managerName
                elif not managerValue:
                    self.debug_stream("In __checkChannelManager() "
                                      "excluding %s from filter: channel or "
                                      "function is close" % (attrName))
                    return None
        return attrName

    def __preHardwareRead(self, attrList, window=1):
        '''Given a list of attributes to be read, prepare it.
           - Divide the attributes to be read in subsets of QueryWindow size.
           - Build the concatenations of queries per subset.
           Example: QueryWindow = 4
           Input: attrList = [a1,a2,a3,a4,a5,a6,a7,a8,a9,a10]
           Output: subsetsIndexes = [[a1,a2,a3,a4],
                                     [a5,a6,a7,a8],
                                     [a9,a10]]
                   subsetsQueries = ["cmd;cmd;cmd;cmd;",
                                     "cmd;cmd;cmd;cmd;",
                                     "cmd;cmd;"]
        '''
        try:
            subsetsIndexes = []
            subsetsQueries = []
            for i in range(0, len(attrList), window):
                subsetsIndexes.append(attrList[i:i+window])
                subsetsQueries.append("")
                for j in range(len(subsetsIndexes[len(subsetsIndexes)-1])):
                    attrName = subsetsIndexes[len(subsetsIndexes)-1][j]
                    attrCmd = self.attributes[attrName].readCmd
                    subsetsQueries[len(subsetsQueries)-1] = \
                        "%s%s;" % (subsetsQueries[len(subsetsQueries)-1],
                                   attrCmd)
            return subsetsIndexes, subsetsQueries
        except Exception as e:
            self.error_stream("In __preHardwareRead() Exception: %s" % (e))
            return None, None

    # @hardwareMutex
    def __hardwareRead(self, query, ask_for_values=False):
        '''Given a string with a ';' separated list of scpi commands 'ask'
           to the instrument and return what the instrument responds.
        '''
        try:
            self.debug_stream("Asking: %r" % (query))
            if ask_for_values:
                answer = self._instrument.ask_for_values(query)
            else:
                answer = self._instrument.ask(query)
            self.debug_stream("Answer: %r" % (answer))
            if answer == '':
                return None
            return answer
        except MemoryError as e:
            self.error_stream("In __hardwareRead() MemoryError exception: %s"
                              % (e))
            traceback.print_exc()
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Device memory error!")
            return None
        except Exception as e:
            self.error_stream("In __hardwareRead() Exception: %s" % (e))
            traceback.print_exc()
            self.__reconnectProcedure()
            return None

    # @hardwareMutex
    def __hardwareWrite(self, cmd):
        '''
        '''
        try:
            self.debug_stream("Writing: %r" % (cmd))
            self._instrument.write(cmd)
        except MemoryError as e:
            self.error_stream("In __hardwareWrite() MemoryError exception: %s"
                              % (e))
            traceback.print_exc()
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Device memory error!")
            return None
        except Exception as e:
            self.error_stream("In __hardwareWrite() Exception: %s" % (e))
            traceback.print_exc()
            self.__reconnectProcedure()

    def __postHardwareScalarRead(self, indexes, answers):
        '''Given the answers organise them in the self.attributes dictionary.
           Example: QueryWindow = 4
           Input: indexes = [[a1,a2,a3,a4],
                             [a5,a6,a7,a8],
                             [a9,a10]]
                  answers = ["ans;ans;ans;ans;",
                             "ans;ans;ans;ans;",
                             "ans;ans;"]
        '''
        t = time.time()
        try:
            attrWithEvents = []
            for i, answer in enumerate(answers):
                if answer is not None:
                    for j, value in enumerate(answer.split('\n')[0]
                                              .split(';')):
                        attrName = indexes[i][j]
                        try:
                            # With formulas, they will be responsible to build
                            # the conversion.
                            if self.attributes[attrName].readFormula:
                                self.attributes[attrName].lastReadValue = value
                            # old way tries the transformation based on
                            # attribute type information.
                            elif self.__isScalarBoolean(attrName, value):
                                pass
                            elif self.__isScalarInteger(attrName, value):
                                pass
                            elif self.__isScalarFloat(attrName, value):
                                pass
                            elif self.__isScalarString(attrName, value):
                                pass
                            else:
                                self.warn_stream("In __postHardwareScalarRead"
                                                 "() Unrecognized data type "
                                                 "for %s" % (attrName))
                                self.attributes[attrName].lastReadValue = \
                                    value
                        except Exception as e:
                            self.error_stream("In __postHardwareScalarRead() "
                                              "Exception of attribute %s: %s"
                                              % (attrName, e))
                            traceback.print_exc()
                            self.attributes[attrName].lastReadValue = None
                            self.attributes[attrName].quality = \
                                PyTango.AttrQuality.ATTR_INVALID
                        finally:
                            self.attributes[attrName].timestamp = t
                            multiattr = self.get_device_attr()
                            attrId = multiattr.get_attr_ind_by_name(attrName)
                            if self.__isRamping(attrName):
                                self.attributes[attrName].quality = \
                                    PyTango.AttrQuality.ATTR_CHANGING
                            elif self.attributes[attrName].quality != \
                                    PyTango.AttrQuality.ATTR_VALID:
                                self.attributes[attrName].quality = \
                                    PyTango.AttrQuality.ATTR_VALID
                            if attrId in self._monitoredAttributeIds:
                                attrWithEvents.\
                                    append([attrName,
                                            self.attributes[attrName].
                                            lastReadValue,
                                            self.attributes[attrName].quality
                                            ])
                else:
                    self.error_stream("In __postHardwareScalarRead() "
                                      "answer %s is None" % (i))
            self.fireEventsList(attrWithEvents)
        except Exception as e:
            self.error_stream("In __postHardwareScalarRead() Exception: %s"
                              % (e))

    def __isScalarBoolean(self, attrName, attrValue):
        if self.attributes[attrName].type in \
                [PyTango.CmdArgType.DevBoolean]:
            self.attributes[attrName].lastReadValue = bool(int(attrValue))
            self.attributes[attrName].quality = \
                PyTango.AttrQuality.ATTR_VALID
            return True
        else:
            return False

    def __isScalarInteger(self, attrName, attrValue):
        if self.attributes[attrName].type in [PyTango.CmdArgType.DevUChar,
                                              PyTango.CmdArgType.DevUShort,
                                              PyTango.CmdArgType.DevShort,
                                              PyTango.CmdArgType.DevULong,
                                              PyTango.CmdArgType.DevLong,
                                              PyTango.CmdArgType.DevULong64,
                                              PyTango.CmdArgType.DevLong64]:
            self.attributes[attrName].lastReadValue = int(attrValue)
            self.attributes[attrName].quality = \
                PyTango.AttrQuality.ATTR_VALID
            return True
        else:
            return False

    def __isScalarFloat(self, attrName, attrValue):
        if self.attributes[attrName].type in [PyTango.CmdArgType.DevFloat,
                                              PyTango.CmdArgType.DevDouble]:
            if attrValue == '9.99999E+37':
                # this is the instrument tag for non measurable
                self.attributes[attrName].lastReadValue = float('NaN')
                self.attributes[attrName].quality = \
                    PyTango.AttrQuality.ATTR_WARNING
            else:
                self.attributes[attrName].lastReadValue = float(attrValue)
                self.attributes[attrName].quality = \
                    PyTango.AttrQuality.ATTR_VALID
            return True
        else:
            return False

    def __isScalarString(self, attrName, attrValue):
        if self.attributes[attrName].type in [PyTango.CmdArgType.DevString]:
            self.attributes[attrName].lastReadValue = str(attrValue)
            self.attributes[attrName].quality = \
                PyTango.AttrQuality.ATTR_VALID
            return True
        else:
            return False

    def __isRamping(self, attrName):
        isRamping = False
        try:
            if self.attributes[attrName].isRampeable() and \
                    self.attributes[attrName].rampThread is not None and \
                    self.attributes[attrName].rampThread.isAlive():
                isRamping = True
        except Exception as e:
            self.warn_stream("%s ramping question exception: %s"
                             % (attrName, e))
        return isRamping

    def __postHardwareSpectrumRead(self, indexes, answers):
        '''Given the answers organise them in the self.attributes dictionary.
           QueryWindow doesn't apply here, the spectrums are made in
           separated reads
           Input: indexes = [[s1],
                             [s2],
                             [a3]]
                  answers = ["f1,f2,f3,f4,...,fn",
                             "f1,f2,f3,f4,...,fn",,
                             "f1,f2,f3,f4,...,fn",]
           A waveform has always a first character '#'
           The second is a char with the number of elements in the next
           variable field. The third, represented with Rs, are the number of
           elements in the waveform that comes next.
           Example: answer = #532017... means, 5 elements will be in the second
                    field, and there will be 32017 elements in the third.
        '''
        t = time.time()
        try:
            attrWithEvents = []
            for i, answer in enumerate(answers):
                attrName = indexes[i][0]
                if 'WaveformDataFormat' in self.attributes:
                    dataFormat =\
                        self.attributes['WaveformDataFormat'].lastReadValue
                    if dataFormat.startswith('ASC'):
                        if self.attributes[attrName].hasRawData():
                            self.attributes[attrName].lastReadRaw = answer
                        self.attributes[attrName].lastReadValue = \
                            numpy.fromstring(answer, dtype=float, sep=',')
                        self.attributes[attrName].timestamp = t
                        self.attributes[attrName].quality = \
                            PyTango.AttrQuality.ATTR_VALID
                    else:
                        # process the header
                        if not answer[0] == '#':
                            self.error_stream("Wrong data receiver for the "
                                              "attribute %s" % (attrName))
                            return
                        # save values for debugging
                        self.attributes[attrName].lastReadRaw = answer
                        # review the header, in answer[0] there is the '#' tag
                        headerSize = int(answer[1])
                        bodySize = int(answer[2:2+headerSize])
                        bodyBlock = answer[2+headerSize:
                                           2+headerSize+bodySize]
                        self.debug_stream("In __postHardwareSpectrumRead() "
                                          "waveform data: header size %d "
                                          "bytes, wave size %d bytes (%d)"
                                          % (2+headerSize, bodySize,
                                             len(bodyBlock)))
                        # prepare interpretation of the raw data
                        if dataFormat.startswith('BYT'):
                            format = 'b'  # signed char, 1byte
                            divisor = 1
                        elif dataFormat.startswith('WORD'):
                            format = 'h'  # signed short, 2byte
                            divisor = 2
                        elif dataFormat.lower() in ['real,32', 'asc']:
                            format = 'I'
                            divisor = 4
                        else:
                            self.error_stream("Cannot decodify data receiver "
                                              "for the attribute %s (%s)"
                                              % (attrName, dataFormat))
                            self.attributes[attrName].lastReadValue = []
                            self.attributes[attrName].timestamp = t
                            self.attributes[attrName].quality = \
                                PyTango.AttrQuality.ATTR_INVALID
                            break
                        nIncompleteBytes = (len(bodyBlock) % divisor)
                        nCompletBytes = len(bodyBlock) - nIncompleteBytes
                        completBytes = bodyBlock[:nCompletBytes]
                        self.debug_stream("With %d bytes, found %d "
                                          "complete packs and %d "
                                          "incomplete. (Expected %d "
                                          "single values)"
                                          % (len(bodyBlock), nCompletBytes,
                                             nIncompleteBytes,
                                             nCompletBytes/divisor))
                        # convert the received input to integers
                        self.debug_stream("completBytes: %r" % completBytes)
                        try:
                            unpackInt = struct.unpack(
                                format*(nCompletBytes/divisor), completBytes)
                            self.debug_stream("Unpacked: %s" % unpackInt)
                        except Exception as e:
                            self.error_stream("Data cannot be unpacked: %s"
                                              % (e))
                        else:
                            # expand the input when each float is codified in
                            # less than 4 bytes
                            floats = numpy.array(unpackInt, dtype=float)
                            if 'WaveformOrigin' in self.attributes and \
                                    'WaveformIncrement' in self.attributes:
                                waveorigin =\
                                    self.attributes['WaveformOrigin'].\
                                    lastReadValue
                                waveincrement =\
                                    self.attributes['WaveformIncrement'].\
                                    lastReadValue
                                self.attributes[attrName].lastReadValue = \
                                    (waveorigin + (waveincrement * floats))
                                self.attributes[attrName].timestamp = t
                                self.attributes[attrName].quality = \
                                    PyTango.AttrQuality.ATTR_VALID
                else:
                    self.warn_stream("In __postHardwareSpectrumRead() "
                                     "Unrecognised spectrum attribute, "
                                     "storing raw data")
                    self.attributes[attrName].lastReadValue = answer
                    self.attributes[attrName].timestamp = t
                    self.attributes[attrName].quality = \
                        PyTango.AttrQuality.ATTR_VALID
                multiattr = self.get_device_attr()
                attrId = multiattr.get_attr_ind_by_name(attrName)
                if attrId in self._monitoredAttributeIds:
                    attrWithEvents.append(
                        [attrName, self.attributes[attrName].lastReadValue,
                         self.attributes[attrName].quality])
            self.fireEventsList(attrWithEvents)
        except Exception as e:
            self.error_stream("In __postHardwareSpectrumRead() Exception: %s"
                              % (e))
            traceback.print_exc()

    @instructionSet.AttrExc
    def read_attr(self, attr):
        if self.get_state() in [PyTango.DevState.FAULT]:
            attr.set_value_date_quality(0, time.time(),
                                                PyTango.AttrQuality.
                                                ATTR_INVALID)
            return
        attrName = attr.get_name()
        if attrName in self.attributes:
            value = self.attributes[attrName].rvalue
            timestamp = self.attributes[attrName].timestamp
            quality = self.attributes[attrName].quality
            if self.attributes[attrName].dim == 0:
                if value is None:
                    attr.set_value_date_quality(0, time.time(),
                                                PyTango.AttrQuality.
                                                ATTR_INVALID)
                else:
                    attr.set_value_date_quality(value, timestamp, quality)
            elif self.attributes[attrName].dim == 1:
                if value is None:
                    attr.set_value_date_quality([0], time.time(),
                                                PyTango.AttrQuality.
                                                ATTR_INVALID, 1)
                else:
                    attr.set_value_date_quality(value, timestamp, quality,
                                                len(value))
            if self.attributes[attrName].isWritable():
                wvalue = self.attributes[attrName].lastWriteValue
                if wvalue is not None:
                    attr.set_write_value(wvalue)
                else:
                    attr.set_write_value(value)
                # when there has been no read (yet) avoid the Non-initialised.
        elif attrName.endswith("Step"):
            parentAttrName = attrName.split('Step')[0]
            value = self.attributes[parentAttrName].rampStep
            if value is None:
                attr.set_value_date_quality(0, time.time(),
                                            PyTango.AttrQuality.ATTR_INVALID)
            else:
                attr.set_value(value)
        elif attrName.endswith("StepSpeed"):
            parentAttrName = attrName.split('StepSpeed')[0]
            value = self.attributes[parentAttrName].rampStepSpeed
            if value is None:
                attr.set_value_date_quality(0, time.time(),
                                            PyTango.AttrQuality.ATTR_INVALID)
            else:
                attr.set_value(value)
        else:
            raise AttributeError("Invalid read of the attribute %s"
                                 % (attrName))

    @instructionSet.AttrExc
    def write_attr(self, attr):
        '''The execution of this method starts with three different branches:
           - An instrument attribute to be send. This splits in two branches
             also:
             - Direct write
             - Launch a thread (if not yet) to drive a ramp to the setpoint
           - The other two are the internal ramp attributes
           - Other case, raise an exception
        '''
        if self.get_state() in [PyTango.DevState.FAULT]:
            raise EnvironmentError("Not allowed to write in %s state"
                                   % (self.get_state()))
        attrName = attr.get_name()
        data = []
        attr.get_write_value(data)
        if attrName in self.attributes:
            self.__write_instrument_attr(attr, attrName, data)
        elif attrName.endswith("Step"):
            parentAttrName = attrName.split('Step')[0]
            self.attributes[parentAttrName].rampStep = data[0]
        elif attrName.endswith("StepSpeed"):
            parentAttrName = attrName.split('StepSpeed')[0]
            self.attributes[parentAttrName].rampStepSpeed = data[0]
        else:
            raise AttributeError("Invalid write of the attribute %s"
                                 % (attrName))

    def __write_instrument_attr(self, attr, attrName, data):
        self.attributes[attrName].lastWriteValue = data[0]
        # Normal case, non rampeable attribute
        if not self.attributes[attrName].isWritable():
            raise AttributeError("%s is not writable attribute"
                                 % (attr.get_name()))
        if not self.attributes[attrName].isRampeable():
            cmd = self.attributes[attrName].writeCmd(data[0])
            # filter the write value if the attribute was configured this way
            if self.attributes[attrName].hasWriteValues() and \
                    not str(data[0]).upper() in \
                    self.attributes[attrName].writeValues:
                self.error_stream("In __write_instrument_attr() avoid to "
                                  "send: %s because it is not in %s"
                                  % (cmd, self.attributes[attrName].writeValues))
                raise AttributeError("Invalid write value %r of the "
                                     "attribute %s" % (data[0], attrName))
            else:
                self.info_stream("In __write_instrument_attr() sending: %s "
                                 "= %r" % (attrName, cmd))
                self.__hardwareWrite(cmd)
        else:
            # rampeable but invalid ramp
            if self.attributes[attrName].rampStep in [None, 0.0] or \
                    self.attributes[attrName].rampStepSpeed in [None, 0.0]:
                self.warn_stream("In __write_instrument_attr() No ramp "
                                 "parameters defined, direct setpoint for %s"
                                 % (attrName))
                cmd = self.attributes[attrName].writeCmd(data[0])
                self.info_stream("In __write_instrument_attr() sending: %s"
                                 % (cmd))
                self.__hardwareWrite(cmd)
            else:
                # rampeable and create a thread, if it doesn't exist
                if self.attributes[attrName].isRampeable() is None:
                    self.info_stream("In __write_instrument_attr() launching "
                                     "ramp procedure for %s to setpoint %g"
                                     % (attrName,
                                        self.attributes[attrName].
                                        lastWriteValue))
                    self.attributes[attrName].rampThread = \
                        threading.Thread(target=self._rampStepper,
                                         name="%s_ramp" % (attrName),
                                         args=([attrName]))
                    self.attributes[attrName].rampThread.setDaemon(True)
                    self.attributes[attrName].rampThread.start()
                else:
                    self.info_stream("In __write_instrument_attr(), attribute"
                                     "%s already with an ongoing ramp. Final "
                                     "setpoint changed to %g."
                                     % (attrName,
                                        self.attributes[attrName].
                                        lastWriteValue))
                # no else need because during the ramp the it goes to
                # 'lastWriteValue' and it has been already updated.

    def _rampStepper(self, attrName):
        # Remember the arguments when this is called as thread target, is a
        # tuple and the content of this tuple is a list with one string
        # element.
        self.info_stream("In _rampStepper(%s)" % (attrName))
        # prepare
        backup_state = self.get_state()
        self.change_state(PyTango.DevState.MOVING)
        self.rebuildStatus()
        attrReadCmd = self.attributes[attrName].readCmd
        # move
        self.attributes[attrName].lastReadValue = \
            float(self.__hardwareRead(attrReadCmd))
        current_pos = self.attributes[attrName].lastReadValue
        self.info_stream("In _rampSteeper(): started the movement from %f"
                         % (current_pos))
        while not current_pos == self.attributes[attrName].lastWriteValue:
            if current_pos > self.attributes[attrName].lastWriteValue:
                if current_pos - self.attributes[attrName].lastWriteValue <\
                        self.attributes[attrName].rampStep:
                    current_pos = self.attributes[attrName].lastWriteValue
                else:
                    current_pos -= self.attributes[attrName].rampStep
            elif current_pos < self.attributes[attrName].lastWriteValue:
                if self.attributes[attrName].lastWriteValue -\
                        current_pos < self.attributes[attrName].rampStep:
                    current_pos = self.attributes[attrName].lastWriteValue
                else:
                    current_pos += self.attributes[attrName].rampStep
            attrWriteCmd = self.attributes[attrName].writeCmd(current_pos)
            self.info_stream("In write_attr() sending: %s" % (attrWriteCmd))
            self.__hardwareWrite(attrWriteCmd)
            time.sleep(self.attributes[attrName].rampStepSpeed)
        self.info_stream("In _rampSteeper(): finished the movement at %f"
                         % (current_pos))
        # close
        self.change_state(backup_state)
        self.rebuildStatus()
        self.attributes[attrName].rampThread = None

    # done dynamic attributes builder section ---
    ######

    ######
    # event manager section ---
    def fireEventsList(self, eventsAttrList):
        timestamp = time.time()
        for attrEvent in eventsAttrList:
            try:
                if len(attrEvent) == 3:  # if it specifies quality
                    self.push_change_event(attrEvent[0], attrEvent[1],
                                           timestamp, attrEvent[2])
                else:
                    self.push_change_event(attrEvent[0], attrEvent[1],
                                           timestamp,
                                           PyTango.AttrQuality.ATTR_VALID)
            except Exception as e:
                self.error_stream("In fireEventsList() Exception with "
                                  "attribute %s: %s" % (attrEvent[0], e))
    # @todo: clean the important logs when they loose importance.

    @stateMutex
    def change_state(self, newstate):
        try:
            self.info_stream("In change_state(%s)" % (str(newstate)))
            if newstate != self.get_state():
                try:
                    self.push_change_event('State', newstate)
                except PyTango.DevFailed as e:
                    self.error_stream("In change_state() push_change_event "
                                      "DevFailed: %s" % (e))
                    traceback.print_exc()
                try:
                    self.set_state(newstate)
                except PyTango.DevFailed as e:
                    self.error_stream("In change_state() set_state "
                                      "DevFailed: %s" % (e))
                    traceback.print_exc()
        except Exception as e:
            self.error_stream("In change_state() Exception: %s" % (e))

    @stateMutex
    def change_status(self, newstatus):
        try:
            self.info_stream("In change_status(): %r" % (str(newstatus)))
            if newstatus != self.get_status():
                try:
                    self.push_change_event('Status', newstatus)
                except PyTango.DevFailed as e:
                    self.error_stream("In change_status() push_change_event "
                                      "DevFailed: %s" % (e))
                    traceback.print_exc()
                try:
                    self.set_status(newstatus)
                except PyTango.DevFailed as e:
                    self.error_stream("In change_status() set_status "
                                      "DevFailed: %s" % (e))
                    traceback.print_exc()
        except Exception as e:
            self.error_stream("In change_status() Exception: %s" % (e))

    def cleanAllImportantLogs(self):
        try:
            self.debug_stream("In cleanAllImportantLogs()")
            self._important_logs = []
            self.addStatusMsg("")
        except PyTango.DevFailed as e:
            self.error_stream("In cleanAllImportantLogs() Exception: %s" % (e))
            traceback.print_exc()
        except Exception as e:
            self.error_stream("In cleanAllImportantLogs() Exception: %s" % (e))

    def addStatusMsg(self, newStatusLine, important=False):
        self.debug_stream("In addStatusMsg()")
        msg = "The device is in %s state.\n" % (self.get_state())
        for ilog in self._important_logs:
            msg = "%s%s\n" % (msg, ilog)
        status = "%s%s"%(msg, newStatusLine)
        self.change_status(status)
        try:
            if important and newStatusLine not in self._important_logs:
                self._important_logs.append(newStatusLine)
        except Exception as e:
            self.warn_stream("In addStatusMsg() cannot append the new "
                             "important log '%s'" % (newStatusLine))

    def rebuildStatus(self):
        try:
            self.cleanAllImportantLogs()
            if len(self.MonitoredAttributes) > 0:
                self.addStatusMsg("Attributes monitored: %r"
                                  % (self.MonitoredAttributes), important=True)
            if hasattr(self, '_alarmDueToMonitoring') and \
                    len(self._alarmDueToMonitoring) > 0:
                self.addStatusMsg("Attributes %r required too much time "
                                  "to be read"
                                  % (self._alarmDueToMonitoring),
                                  important=True)
        except Exception as e:
            self.error_stream("In rebuildStatus() Exception: %s" % (e))
    # done event manager section ---
    ######

    ######
    # attribute monitor section ---
    def __builtMonitorThread(self, name, period):
        scheleton = {'Name': name,  # Only used to output a message
                                    # when threads start
                     'Thread': None,
                     'Event': threading.Event(),
                     'Period': period,
                     'AttrList': []}
        scheleton['Event'].clear()
        return scheleton

    def __prepareMonitor(self):
        ''' - The lines in the property 'MonitoredAttributes' defines an
            attribute name to be monitored (with an optional tag of an
            special period):
                attrName[:period]
            - The attributes must be stored in an Id way in a list, to
            simplify the filter when 'self.read_attr_hardware()' is called by
            a PyTango.DeviceProxy.read_attributes([]) or
            PyTango.DeviceProxy.read_attribute()
            - There is a thread for generic monitoring, the period of it
            is the 'TimeStampsThreashold' to have it as updated as possible.
            - Other periods will collect the ones with the same period in
              one thread.
            - The monitored attributes will have events.
        '''
        try:
            multiattr = self.get_device_attr()
            self._monitorThreads = {}
            self._generalMonitorEvent = threading.Event()
            self._generalMonitorEvent.clear()
            self._monitoredAttributeIds = []
            self._alarmDueToMonitoring = []
            for attrName in self.MonitoredAttributes:
                if not attrName.count(':'):  # Normal monitoring
                    monitoringType = 'Generic'
                    attrPeriod = self.attr_TimeStampsThreshold_read
                    attrId = multiattr.get_attr_ind_by_name(attrName)
                else:
                    attrName, attrPeriod = attrName.split(':')
                    monitoringType = attrPeriod
                    attrPeriod = float(attrPeriod)
                    attrId = multiattr.get_attr_ind_by_name(attrName)
                # Once initialised they can be build by reference
                if attrName not in self.attributes.keys():
                    self.error_stream("The name %s is not an attribute in "
                                      "this device" % (attrName))
                elif attrId in self._monitoredAttributeIds:
                    self.error_stream("The attribute %s is configured to "
                                      "be monitored more than one time"
                                      % (attrName))
                else:  # once here link it with the appropriate thread
                    self.debug_stream("Preparing the attribute %s for "
                                      "the %s monitoring"
                                      % (attrName, monitoringType))
                    self._monitoredAttributeIds.append(attrId)
                    if monitoringType not in self._monitorThreads:
                        self._monitorThreads[monitoringType] = \
                            self.__builtMonitorThread(monitoringType,
                                                      attrPeriod)
                    self._monitorThreads[monitoringType]['AttrList'].\
                        append(attrName)
        except Exception as e:
            self.error_stream("In __prepareMonitor() Exception: %s" % (e))

    def __startMonitoring(self):
        try:
            self._generalMonitorEvent.clear()
            for monitorTag in self._monitorThreads.keys():
                self._monitorThreads[monitorTag]['Thread'] = \
                    threading.Thread(target=self.__monitor, name="monitor",
                                     args=([self._monitorThreads[monitorTag]]))
                self._monitorThreads[monitorTag]['Event'].clear()
                self._monitorThreads[monitorTag]['Thread'].setDaemon(True)
                for attrName in self._monitorThreads[monitorTag]['AttrList']:
                    self.set_change_event(attrName, True, False)
                self._monitorThreads[monitorTag]['Thread'].start()
            self.change_state(PyTango.DevState.RUNNING)
            self.rebuildStatus()
        except Exception as e:
            self.error_stream("In __startMonitoring() Exception: %s" % (e))

    def __endMonitoring(self):
        self.info_stream("In __endMonitoring() waiting for %d"
                         % (len(self._monitorThreads.keys())))
        self._generalMonitorEvent.set()
        while any([self._monitorThreads[monitorTag]['Thread'].isAlive()
                   for monitorTag in self._monitorThreads.keys()]):
            self.info_stream("In __endMonitoring() waiting for %d"
                             % (len(self._monitorThreads.keys())))
            time.sleep(0.5)
        self.change_state(PyTango.DevState.ON)
        self.rebuildStatus()
        self.__prepareMonitor()

    def __buildIdList(self, attrList):
        multiattr = self.get_device_attr()
        IdsList = []
        for attrName in attrList:
            IdsList.append(multiattr.get_attr_ind_by_name(attrName))
        return IdsList

    def _checkArginNameAndPeriod(self, argin):
        try:
            self.debug_stream("Checking %s argin" % (argin))
            if type(argin) == str:
                self.debug_stream("%s is an string" % (argin))
                if argin.count('[') == 1 and argin.count(']') == 1:
                    self.debug_stream("%s has brakets" % (argin))
                    lst = argin[argin.index('[')+1:argin.rindex(']')]
                else:
                    self.debug_stream("%s haven't brakets" % (argin))
                    lst = argin
                if lst.count(',') == 1 or lst.count(':') == 1:
                    # attrName,attrPeriod or attrName:attrPeriod or
                    # [attrName,attrPeriod] or [attrName:attrPeriod]
                    self.debug_stream("%s contains attrPeriod" % (argin))
                    if lst.count(',') == 1:
                        attrName, attrPeriod = argin.split(',')
                    elif lst.count(':') == 1:
                        attrName, attrPeriod = argin.split(':')
                    attrPeriod = float(attrPeriod)
                else:  # attrName or [attrName]
                    self.debug_stream("%s contain only the attrName" % (argin))
                    attrName = lst
                    attrPeriod = None
                if attrName.count('\''):
                    attrName = attrName.strip('\'')
                return attrName, attrPeriod
            if type(argin) == list:
                if len(argin) == 1:
                    attrName = argin[0]
                    attrPeriod = None
                elif len(argin) == 2:
                    attrName = argin[0]
                    attrPeriod = float(argin[1])
                else:
                    raise AttributeError("Invalid arguments, use [attrName] "
                                         "or [attrName, attrPeriod]")
                return attrName, attrPeriod
        except Exception as e:
            raise SyntaxError("Invalid arguments, use [attrName] "
                              "or [attrName, attrPeriod] and check reason "
                              "%s" % (e))

    def __monitor(self, monitorDict):
        '''This is the method where every monitor thread will live.
        '''
        self.info_stream("Monitoring thread '%s' announcing its START. "
                         "Attributes: %r" % (monitorDict['Name'],
                                             monitorDict['AttrList']))
        attrList = []
        while not self._generalMonitorEvent.is_set() and \
                not monitorDict['Event'].is_set():
            if not len(attrList) == len(monitorDict['AttrList']):
                attrList = copy.copy(monitorDict['AttrList'])
                attrIds = self.__buildIdList(monitorDict['AttrList'])
                self.info_stream("In __monitor(), thread %s, the "
                                 "attribute list has change to %r"
                                 % (monitorDict['Name'],
                                    monitorDict['AttrList']))
            if len(attrList) == 0:
                monitorDict['Event'].set()
            else:
                t0 = time.time()
                self.__read_attr_procedure(attrIds, fromMonitor=True)
                tf = time.time()
                delta_t = monitorDict['Period'] - (tf - t0)
                if delta_t <= 0:  # it take longer than the period
                    self.__appendToAlarmCausingList(attrList)
                else:
                    if self.get_state() == PyTango.DevState.ALARM:
                        self.__removeFromAlarmCausingList(attrList)
                    time.sleep(delta_t)
        self.info_stream("Monitoring thread %s announcing its STOP"
                         % (monitorDict['Name']))
        for AttrName in monitorDict['AttrList']:
            self.set_change_event(AttrName, False, False)
        self._monitorThreads.pop(monitorDict['Name'])

    def __appendToAlarmCausingList(self, attrList):
        for attrName in attrList:
            if attrName not in self._alarmDueToMonitoring:
                self._alarmDueToMonitoring.append(attrName)
        self.rebuildStatus()

    def __removeFromAlarmCausingList(self, attrList):
        for attrName in attrList:
            if self._alarmDueToMonitoring.count(attrName):
                self._alarmDueToMonitoring.pop(
                    self._alarmDueToMonitoring.index(attrName))
        self.rebuildStatus()

    def __appendPropertyElement(self, propertyName, element):
        db = PyTango.Database()
        propertiesDict = db.get_device_property(self.get_name(), propertyName)
        self.debug_stream("propertyName was: %r"
                          % (propertiesDict[propertyName]))
        propertiesDict[propertyName].append(element)
        propertyLst = propertiesDict[propertyName]
        propertyStr = self.__list2strProperty(propertyLst)
        propertiesDict[propertyName] = propertyStr
        self.debug_stream("propertyName now: %r"
                          % (propertiesDict[propertyName]))
        db.put_device_property(self.get_name(), propertiesDict)
        return propertyLst

    def __popPropertyElement(self, propertyName, element):
        db = PyTango.Database()
        propertiesDict = db.get_device_property(self.get_name(), propertyName)
        self.debug_stream("propertyName was: %r"
                          % (propertiesDict[propertyName]))
        propertyList = propertiesDict[propertyName][0].split('\n')
        index = None
        try:
            index = propertyList.index(element)
        except:
            # in case is an specially monitored, previous will
            # throw an exception
            for name in propertyList:
                if name.count(':'):
                    # find, for each element with an special period
                    if element == name.split(':')[0]:
                        # if one corresponds
                        index = propertyList.index(name)
                        break
        if index is None:
            self.warning("In __popPropertyElement() %s not found"
                         % (propertyName))
            return propertyList
        self.debug_stream("In __popPropertyElement() removing %s (index %d)"
                          % (propertyName, index))
        propertyList.pop(index)
        propertiesDict[propertyName] = self.__list2strProperty(propertyList)
        db.put_device_property(self.get_name(), propertiesDict)
        return propertyList

    def __list2strProperty(self, lst):
        strLst = ''.join("%s\n" % each for each in lst)
        self.debug_stream("In __list2strProperty(%s): %r" % (lst, strLst))
        return strLst[:-1]

    def __str2listProperty(self, strLst):
        self.debug_stream("%r" % strLst)
        return strLst.split('\n')
    #----- done attribute monitor section
    ######

#----- PROTECTED REGION END -----#  //  Skippy.global_variables

    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        Skippy.init_device(self)
        #----- PROTECTED REGION ID(Skippy.__init__) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(Skippy.delete_device) ENABLED START -----#
        self._reconnectAwaker.set()
        i = RECONNECT_THREAD_DELETE_TRIES
        while self._reconnectThread is not None and\
                self._reconnectThread.isAlive() and i > 0:
            self.warn_stream("wait for reconnection thread... (%d)" % i)
            self._reconnectThread.join(1)
            i -= 1
        if self._reconnectThread is not None and\
                self._reconnectThread.isAlive():
            self.error_stream("Couldn't wait more for the reconnection thread")
        #----- PROTECTED REGION END -----#  //  Skippy.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_Idn_read = ''
        self.attr_QueryWindow_read = 0
        self.attr_TimeStampsThreshold_read = 0.0
        #----- PROTECTED REGION ID(Skippy.init_device) ENABLED START -----#
        self.attr_TimeStampsThreshold_read = 0.1
        self._idn = None
        self.set_change_event('State', True, False)
        self.set_change_event('Status', True, False)
        self._important_logs = []
        self.prepareMutex()
        self.change_state(PyTango.DevState.INIT)
        self.change_status("Initializing...")
        self.attr_QueryWindow_read = 1  # Not allow 0
        # tools for the Exec() cmd
        DS_MODULE = __import__(self.__class__.__module__)
        kM = dir(DS_MODULE)
        vM = map(DS_MODULE.__getattribute__, kM)
        self.__globals = dict(zip(kM, vM))
        self.__globals['self'] = self
        self.__globals['module'] = DS_MODULE
        self.__locals = {}
        # prepare the attribute building
        self.attributes={}
        self.attributesFlags = {}
        # Communications
        self._reconnectThread = None
        self._reconnectAwaker = threading.Event()
        self._reconnectAwaker.clear()
        self._commLost = []
        # 1.- if more than N errors during the last M seconds: 
        #     then delay the recovery by S seconds.
        self._lastNErrorsThreshold = DEFAULT_ERRORS_THRESHOLD
        self._lastMSeconds = DEFAULT_RECOVERY_DELAY
        self._recoveryDelay = MINIMUM_RECOVERY_DELAY
        # 2.- if last delayed recovery comes from less than R seconds:
        #     then double the S time.
        self._recoverThreshold = 120.0
        self._lastRecovery = None
        # conversion of the MonitoredAttributes property, 
        # from string list to list
        try:
            attrLst = str(self.MonitoredAttributes[0])
            self.MonitoredAttributes = self.__str2listProperty(attrLst)
        except:
            self.info_stream("No monitored attributes defined")
        #---- once initialized, begin the process to connect with the instrument
        self._instrument = None
        self._builder = None
        self.__buildInstrumentObj()
        if not self.AutoStandby:
            self.debug_stream("Configured to NOT progress to StandBy")
            return
        self.Standby()
        if not self.AutoOn:
            self.debug_stream("Configured to NOT progress to On")
            return
        self.On()
        # TODO: flag to distinguish the minimal communications in STANDBY and
        #       the normal queries of the ON
        if not self.AutoStart:
            self.debug_stream("Configured to NOT progress to Start")
            return
        self.Start()
        #----- PROTECTED REGION END -----#  //  Skippy.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(Skippy.always_executed_hook) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.always_executed_hook

    #-----------------------------------------------------------------------------
    #    Skippy read/write attribute methods
    #-----------------------------------------------------------------------------
    
    def read_Idn(self, attr):
        self.debug_stream("In read_Idn()")
        #----- PROTECTED REGION ID(Skippy.Idn_read) ENABLED START -----#
        try:
            self.attr_Idn_read = self._idn
            attr.set_value(self.attr_Idn_read)
        except Exception as e:
            self.error_stream("Couldn't read the IDN attribute: %s" % (e))
            attr.set_value_date_quality("", time.time(),
                                        PyTango.AttrQuality.ATTR_INVALID)
            return
        #----- PROTECTED REGION END -----#  //  Skippy.Idn_read
        
    def is_Idn_allowed(self, attr):
        self.debug_stream("In is_Idn_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(Skippy.is_Idn_allowed) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.is_Idn_allowed
        return state_ok
        
    def read_QueryWindow(self, attr):
        self.debug_stream("In read_QueryWindow()")
        #----- PROTECTED REGION ID(Skippy.QueryWindow_read) ENABLED START -----#
        attr.set_value(self.attr_QueryWindow_read)
        #----- PROTECTED REGION END -----#  //  Skippy.QueryWindow_read
        
    def write_QueryWindow(self, attr):
        self.debug_stream("In write_QueryWindow()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(Skippy.QueryWindow_write) ENABLED START -----#
        self.attr_QueryWindow_read = int(data)
        #----- PROTECTED REGION END -----#  //  Skippy.QueryWindow_write
        
    def read_TimeStampsThreshold(self, attr):
        self.debug_stream("In read_TimeStampsThreshold()")
        #----- PROTECTED REGION ID(Skippy.TimeStampsThreshold_read) ENABLED START -----#
        attr.set_value(self.attr_TimeStampsThreshold_read)
        #----- PROTECTED REGION END -----#  //  Skippy.TimeStampsThreshold_read
        
    def write_TimeStampsThreshold(self, attr):
        self.debug_stream("In write_TimeStampsThreshold()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(Skippy.TimeStampsThreshold_write) ENABLED START -----#
        self.attr_TimeStampsThreshold_read = float(data)
        if hasattr(self, '_monitorThreads') and \
                'Generic' in self._monitorThreads:
            self._monitorThreads['Generic']['Period'] = \
                self.attr_TimeStampsThreshold_read
        ## TODO: function of an instrument attribute ---
        #        for a lower limit or to force as unique possibility.
        #----- PROTECTED REGION END -----#  //  Skippy.TimeStampsThreshold_write
        
    
    
        #----- PROTECTED REGION ID(Skippy.initialize_dynamic_attributes) ENABLED START -----#
    def initialize_dynamic_attributes(self):
        pass
        #----- PROTECTED REGION END -----#  //  Skippy.initialize_dynamic_attributes
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(Skippy.read_attr_hardware) ENABLED START -----#
        self.__read_attr_procedure(data)
        #----- PROTECTED REGION END -----#  //  Skippy.read_attr_hardware


    #-----------------------------------------------------------------------------
    #    Skippy command methods
    #-----------------------------------------------------------------------------
    
    def IDN(self):
        """ Request identification to the instrument.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevString """
        self.debug_stream("In IDN()")
        argout = ''
        #----- PROTECTED REGION ID(Skippy.IDN) ENABLED START -----#
        #self._idn = self._instrument.ask("*IDN?")
        idn = self.__hardwareRead("*IDN?")
        if self._idn != idn:
            self.warn_stream("In IDN(): current identity %r has changed to %r"
                             % (self._idn, idn))
            self._idn = idn
        argout = self._idn
        #----- PROTECTED REGION END -----#  //  Skippy.IDN
        return argout
        
    def is_IDN_allowed(self):
        self.debug_stream("In is_IDN_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,PyTango.DevState.DISABLE,
            PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(Skippy.is_IDN_allowed) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.is_IDN_allowed
        return state_ok
        
    def Start(self):
        """ Start an active monitoring.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In Start()")
        argout = False
        #----- PROTECTED REGION ID(Skippy.Start) ENABLED START -----#
        try:
            if self.get_state() == PyTango.DevState.ON and \
                    len(self.MonitoredAttributes)>0:
                self.__startMonitoring()
                argout = True
        except Exception as e:
            self.error_stream("In Start() Exception: %s" % (e))
        #----- PROTECTED REGION END -----#  //  Skippy.Start
        return argout
        
    def is_Start_allowed(self):
        self.debug_stream("In is_Start_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.RUNNING,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT,
            PyTango.DevState.STANDBY])
        #----- PROTECTED REGION ID(Skippy.is_Start_allowed) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.is_Start_allowed
        return state_ok
        
    def Stop(self):
        """ Stop the active monitoring.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In Stop()")
        argout = False
        #----- PROTECTED REGION ID(Skippy.Stop) ENABLED START -----#
        try:
            stopper = threading.Thread(target=self.__endMonitoring,
                                       name="monitor_stopper")
            stopper.setDaemon(True)
            stopper.start()
            argout = True
        except Exception as e:
            self.error_stream("In Stop() Exception: %s" % (e))
        #----- PROTECTED REGION END -----#  //  Skippy.Stop
        return argout
        
    def is_Stop_allowed(self):
        self.debug_stream("In is_Stop_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.ON,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT,
            PyTango.DevState.STANDBY])
        #----- PROTECTED REGION ID(Skippy.is_Stop_allowed) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.is_Stop_allowed
        return state_ok
        
    def On(self):
        """ Allow communication with the instrument.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In On()")
        argout = False
        #----- PROTECTED REGION ID(Skippy.On) ENABLED START -----#
        if self.get_state() == PyTango.DevState.OFF:
            self.Standby()
        if self.__builder():
            self.__prepareMonitor()
            self.change_state(PyTango.DevState.ON)
            self.rebuildStatus()
            argout = True
        #----- PROTECTED REGION END -----#  //  Skippy.On
        return argout
        
    def is_On_allowed(self):
        self.debug_stream("In is_On_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.ON,
            PyTango.DevState.RUNNING,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(Skippy.is_On_allowed) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.is_On_allowed
        return state_ok
        
    def Off(self):
        """ Release the communication with the instrument.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In Off()")
        argout = False
        #----- PROTECTED REGION ID(Skippy.Off) ENABLED START -----#
        if self.get_state() == PyTango.DevState.ON:
            self.Standby()
        try:
            if hasattr(self, '_instrument') and self._instrument is not None:
                self._instrument.close()
        except Exception as e:
            self.error_stream("Cannot disconnect from the instrument "
                              "due to: %s" % (e))
            traceback.print_exc()
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Off command failed")
        else:
            self._idn = ""
            self.info_stream("disconnected to the instrument %s"
                             % (self.Instrument))
            if self._builder is None or self.__unbuilder():
                self.change_state(PyTango.DevState.OFF)
                self.rebuildStatus()
                argout = True
        #----- PROTECTED REGION END -----#  //  Skippy.Off
        return argout
        
    def is_Off_allowed(self):
        self.debug_stream("In is_Off_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.RUNNING,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(Skippy.is_Off_allowed) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.is_Off_allowed
        return state_ok
        
    def Exec(self, argin):
        """ evaluate python code inside the device server. This command can be very helpful and dangerous.
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevString """
        self.debug_stream("In Exec()")
        argout = ''
        #----- PROTECTED REGION ID(Skippy.Exec) ENABLED START -----#
        try:
            try:
                # interpretation as expression
                argout = eval(argin, self.__globals, self.__locals)
            except SyntaxError:
                # interpretation as statement
                exec argin in self.__globals, self.__locals
                argout = self.__locals.get("y")
        except Exception as exc:
            # handles errors on both eval and exec level
            argout = traceback.format_exc()
        if type(argout) == StringType:
            return argout
        elif isinstance(argout, BaseException):
            return "%s!\n%s" % (argout.__class__.__name__, str(argout))
        else:
            try:
                return pprint.pformat(argout)
            except Exception:
                return str(argout)
        #----- PROTECTED REGION END -----#  //  Skippy.Exec
        return argout
        
    def AddMonitoring(self, argin):
        """ Add an attribute to the list of monitored attributes
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In AddMonitoring()")
        argout = False
        #----- PROTECTED REGION ID(Skippy.AddMonitoring) ENABLED START -----#
        try:
            attrName, attrPeriod = self._checkArginNameAndPeriod(argin)
            multiattr = self.get_device_attr()
            attrId = multiattr.get_attr_ind_by_name(attrName)
            if not attrName in self.attributes.keys():
                raise AttributeError("No attribute named %s" % (attrName))
            elif attrId in self._monitoredAttributeIds:
                raise AttributeError("Attribute %s already monitored"
                                     % (attrName))
            else:
                self.info_stream("In AddMonitoring(): Adding %s attribute "\
                                 "to monitoring." % (attrName))
                # manage the property
                try:
                    self.MonitoredAttributes = \
                        self.__appendPropertyElement('MonitoredAttributes',
                                                     attrName)
                    self.debug_stream("In AddMonitoring(%s), added to "
                                     "properties" % (attrName))
                except Exception as e:
                    self.error_stream("In AddMonitoring(%s) cannot append "
                                      "to the property: %s"
                                      %(attrName, e))
                    raise e
                # manage the internal list that monitors
                if attrPeriod == None:
                    attrPeriod = self.attr_TimeStampsThreshold_read
                if attrPeriod == self.attr_TimeStampsThreshold_read:
                    monitoringType = 'Generic'
                else:
                    monitoringType = attrPeriod
                if monitoringType not in self._monitorThreads.keys():
                    self.info_stream("%s monitoring thread doesn't exist, "
                                     "creating" % (monitoringType))
                    self._monitorThreads[monitoringType] = \
                        self.__builtMonitorThread(attrName, attrPeriod)
                else:
                    self.debug_stream("Adding %s to %s monitoring thread"
                                      % (attrName, monitoringType))
                self._monitoredAttributeIds.append(attrId)
                self._monitorThreads[monitoringType]['AttrList'].\
                    append(attrName)
                self.set_change_event(attrName, True, False)
                argout = True
                self.rebuildStatus()
                self.Start()
        except Exception as e:
            self.error_stream("In AddMonitoring(%s) exception: %s"
                              % (argin, e))
            raise e
        #----- PROTECTED REGION END -----#  //  Skippy.AddMonitoring
        return argout
        
    def is_AddMonitoring_allowed(self):
        self.debug_stream("In is_AddMonitoring_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(Skippy.is_AddMonitoring_allowed) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.is_AddMonitoring_allowed
        return state_ok
        
    def RemoveMonitoring(self, argin):
        """ Remove an attribute from the list of monitored attributes
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In RemoveMonitoring()")
        argout = False
        #----- PROTECTED REGION ID(Skippy.RemoveMonitoring) ENABLED START -----#
        try:
            multiattr = self.get_device_attr()
            attrId = multiattr.get_attr_ind_by_name(argin)
            if not argin in self.attributes.keys():
                raise AttributeError("No attribute named %s" % (argin))
            elif not attrId in self._monitoredAttributeIds:
                raise AttributeError("Attribute %s is not monitored" % (argin))
            else:
                # manage the internal monitors
                self.info_stream("In RemoveMonitoring(): Removing %s "
                                 "attribute from monitoring" % (argin))
                for monitorKey in self._monitorThreads.keys():
                    if self._monitorThreads[monitorKey]['AttrList'].\
                            count(argin):
                        self._monitorThreads[monitorKey]['AttrList'].\
                            pop(self._monitorThreads[monitorKey]['AttrList'].\
                                index(argin))
                        self.set_change_event(argin, False, False)
                self._monitoredAttributeIds.pop(
                    self._monitoredAttributeIds.index(attrId))
                # manage the property
                try:
                    self.MonitoredAttributes = \
                        self.__popPropertyElement('MonitoredAttributes', argin)
                    argout = True
                except Exception as e:
                    self.error_stream("In RemoveMonitoring(%s) cannot remove "
                                      "from the property: %s"
                                      % (argin, e))
                    raise e
                self.rebuildStatus()
        except Exception as e:
            self.error_stream("In RemoveMonitoring(%s) exception: %s"
                              % (argin, e))
            raise e
        #----- PROTECTED REGION END -----#  //  Skippy.RemoveMonitoring
        return argout
        
    def is_RemoveMonitoring_allowed(self):
        self.debug_stream("In is_RemoveMonitoring_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(Skippy.is_RemoveMonitoring_allowed) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.is_RemoveMonitoring_allowed
        return state_ok




    def SetMonitoringPeriod(self, argin):
        """ From the list of already monitored attributes, stablish (or change) the period that it is checked.
        
        :param argin: 
        :type: PyTango.DevVarStringArray
        :return: 
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In SetMonitoringPeriod()")
        argout = False
        #----- PROTECTED REGION ID(Skippy.SetMonitoringPeriod) ENABLED START -----#
        try:
            if not len(argin) == 2:
                raise AttributeError("Invalid arguments, "\
                                     "use [attrName, AttrPeriod]")
            else:
                if argin[0].count("'") == 2:
                    attrName = str(argin[0].split("'")[1])
                else:
                    attrName = argin[0]
                if argin[1].count("'") == 2:
                    attrPeriod = float(argin[1].split("'")[1])
                else:
                    attrPeriod = float(argin[1])
                self.info_stream("In SetMonitoringPeriod(%s, %f)"
                                 % (attrName, attrPeriod))
            multiattr = self.get_device_attr()
            attrId = multiattr.get_attr_ind_by_name(attrName)
            if not attrName in self.attributes.keys():
                raise AttributeError("No attribute named %s" % (attrName))
            elif not attrId in self._monitoredAttributeIds:
                raise AttributeError("Attribute %s is not monitored"
                                     % (attrName))
            elif attrPeriod < 0:
                raise AttributeError("Invalid period %f" % (attrPeriod))
            else:
                # Remove from the monitor where it already is:
                for monitorKey in self._monitorThreads.keys():
                    if self._monitorThreads[monitorKey]['AttrList'].\
                            count(attrName):
                        self._monitorThreads[monitorKey]['AttrList'].\
                            pop(self._monitorThreads[monitorKey]['AttrList'].
                                index(attrName))
                        self.MonitoredAttributes = \
                            self.__popPropertyElement('MonitoredAttributes',
                                                      attrName)
                # distinguish if the command should send it to 
                # the generic or not
                monitorTag = str(attrPeriod)
                if attrPeriod == 0:
                    monitorTag = 'Generic'
                else:
                    monitorTag = str(attrPeriod)
                # if there is a thread with this tag use it
                if str(attrPeriod) in self._monitorThreads:
                    self._monitorThreads[monitorTag]['AttrList'].\
                        append(attrName)
                # if not, then build it and start it.
                else:
                    self._monitorThreads[monitorTag] = \
                        self.__builtMonitorThread(monitorTag, attrPeriod)
                    self._monitorThreads[monitorTag]['AttrList'].\
                        append(attrName)
                    if self.get_state() == PyTango.DevState.RUNNING:
                        self._monitorThreads[monitorTag]['Thread'] = \
                            threading.Thread(target=self.__monitor,
                                name="%s_monitor" % (monitorTag),
                                args=([self._monitorThreads[monitorTag]]))
                        self._monitorThreads[monitorTag]['Event'].clear()
                        self._monitorThreads[monitorTag]['Thread'].\
                            setDaemon(True)
                        self._monitorThreads[monitorTag]['Thread'].start()
                if attrPeriod == 0:
                    self.MonitoredAttributes = self.__appendPropertyElement(
                        'MonitoredAttributes', "%s" % (attrName))
                else:
                    self.MonitoredAttributes = self.__appendPropertyElement(
                        'MonitoredAttributes', "%s:%6.3f" % (attrName,
                                                             attrPeriod))
                argout = True
        except Exception as e:
            self.error_stream("In SetMonitoringPeriod(%s) exception: %s"
                              % (argin, e))
            raise e
        #----- PROTECTED REGION END -----#  //  Skippy.SetMonitoringPeriod
        return argout
        
    def is_SetMonitoringPeriod_allowed(self):
        self.debug_stream("In is_SetMonitoringPeriod_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(Skippy.is_SetMonitoringPeriod_allowed) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.is_SetMonitoringPeriod_allowed
        return state_ok
        
    def GetMonitoringPeriod(self, argin):
        """ Get the period that is checked an attribute monitored.
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevFloat """
        self.debug_stream("In GetMonitoringPeriod()")
        argout = 0.0
        #----- PROTECTED REGION ID(Skippy.GetMonitoringPeriod) ENABLED START -----#
        try:
            attrName = argin
            multiattr = self.get_device_attr()
            attrId = multiattr.get_attr_ind_by_name(attrName)
            if not attrName in self.attributes.keys():
                raise AttributeError("No attribute named %s" % (attrName))
            elif not attrId in self._monitoredAttributeIds:
                raise AttributeError("Attribute %s is not monitored"
                                     % (attrName))
            for monitorKey in self._monitorThreads.keys():
                if self._monitorThreads[monitorKey]['AttrList'].count(argin):
                    if monitorKey == 'Generic':
                        argout = self.attr_TimeStampsThreshold_read
                    else:
                        argout = float(monitorKey)
        except Exception as e:
            self.error_stream("In GetMonitoringPeriod(%r) exception: %s"
                              % (argin, e))
            raise e
        #----- PROTECTED REGION END -----#  //  Skippy.GetMonitoringPeriod
        return argout
        
    def is_GetMonitoringPeriod_allowed(self):
        self.debug_stream("In is_GetMonitoringPeriod_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(Skippy.is_GetMonitoringPeriod_allowed) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.is_GetMonitoringPeriod_allowed
        return state_ok
        
    def CMD(self, argin):
        """ Expert command for a direct send of a SCPI command and read the answer.
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevString """
        self.debug_stream("In CMD()")
        argout = ''
        #----- PROTECTED REGION ID(Skippy.CMD) ENABLED START -----#
        argin = str(argin)
        self.info_stream("In CMD(%r)" % (argin))
        try:
            if argin.find('?') >= 0:
                # argout = self._instrument.ask(argin)
                argout = self.__hardwareRead(argin) or ''
            else:
                # self._instrument.write(argin)
                self.__hardwareWrite(argin)
                argout = ""
            self.info_stream("In CMD(%r): %r" % (argin, argout))
        except Exception as e:
            self.error_stream("In CMD(%r) Exception: %s" % (argin, e))
            argout = ""
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Exception while executing CMDfloat()")
            self.__reconnectInstrumentObj()
        #----- PROTECTED REGION END -----#  //  Skippy.CMD
        return argout
        
    def is_CMD_allowed(self):
        self.debug_stream("In is_CMD_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(Skippy.is_CMD_allowed) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.is_CMD_allowed
        return state_ok
        
    def CMDfloat(self, argin):
        """ Expert command for a direct send of a SCPI command and read the answer converted to a float list.
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevVarFloatArray """
        self.debug_stream("In CMDfloat()")
        argout = [0.0]
        #----- PROTECTED REGION ID(Skippy.CMDfloat) ENABLED START -----#
        argin = str(argin)
        self.info_stream("In %s::CMDfloat(%r)" % (self.get_name(), argin))
        try:
            if argin.find('?') >= 0:
                # argout = self._instrument.ask_for_values(argin)
                argout = self.__hardwareRead(argin, ask_for_values=True)
            else:
                # self._instrument.write(argin)
                self.__hardwareWrite(argin)
                argout = float("NaN")
            self.info_stream("In CMDfloat(%r): %r" % (argin, argout))
        except Exception as e:
            self.error_stream("In CMDfloat(%r) Exception: %s" % (argin, e))
            argout = ""
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Exception while executing CMDfloat()")
            self.__reconnectInstrumentObj()
        #----- PROTECTED REGION END -----#  //  Skippy.CMDfloat
        return argout
        
    def is_CMDfloat_allowed(self):
        self.debug_stream("In is_CMDfloat_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(Skippy.is_CMDfloat_allowed) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.is_CMDfloat_allowed
        return state_ok
        
    def Standby(self):
        """ Stablish communication with the instrument.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In Standby()")
        argout = False
        #----- PROTECTED REGION ID(Skippy.Standby) ENABLED START -----#
        if self.get_state() == PyTango.DevState.OFF:
            #if self.__buildInstrumentObj():
                if self.__connectInstrumentObj():
                    self.change_state(PyTango.DevState.STANDBY)
                    self.rebuildStatus()
                    argout = True
                else:
                    self.__reconnectProcedure()
                    argout = False
        elif self.get_state() == PyTango.DevState.ON:
            if self._builder is None or self.__unbuilder():
                self.change_state(PyTango.DevState.STANDBY)
                self.rebuildStatus()
                argout = True
        #----- PROTECTED REGION END -----#  //  Skippy.Standby
        return argout
        

    #----- PROTECTED REGION ID(Skippy.programmer_methods) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#  //  Skippy.programmer_methods

class SkippyClass(PyTango.DeviceClass):
    #--------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(Skippy.global_class_variables) ENABLED START -----#

    #----- PROTECTED REGION END -----#  //  Skippy.global_class_variables

    def dyn_attr(self, dev_list):
        """Invoked to create dynamic attributes for the given devices.
        Default implementation calls
        :meth:`Skippy.initialize_dynamic_attributes` for each device
    
        :param dev_list: list of devices
        :type dev_list: :class:`PyTango.DeviceImpl`"""
    
        for dev in dev_list:
            try:
                dev.initialize_dynamic_attributes()
            except:
                import traceback
                dev.warn_stream("Failed to initialize dynamic attributes")
                dev.debug_stream("Details: " + traceback.format_exc())
        #----- PROTECTED REGION ID(Skippy.dyn_attr) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.dyn_attr

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'Instrument':
            [PyTango.DevString,
            "The name of the instrument to use. This may be:\
                1: host name to connect to\
                2: PyVisa tango device name to connect to\
                3: Serial or PySerial tango device to connect to\
                4: serial device name for direct connection (e.g. /dev/ttyS0)",
            [] ],
        'Port':
            [PyTango.DevUShort,
            "In case of socket interface the port value can be changed",
            [5025]],
        'SerialBaudrate':
            [PyTango.DevULong,
            "Baudrate of serial port (only for direct serial connection)",
            [9600]],
        'SerialBytesize':
            [PyTango.DevUShort,
            "Bytesize of serial port (only for direct serial connection)",
            [8]],
        'SerialParity':
            [PyTango.DevString,
            "Parity of serial port (only for direct serial connection)",
            ["N"]],
        'SerialStopbits':
            [PyTango.DevUShort,
            "Stopbits of serial port (only for direct serial connection)",
            [1]],
        'SerialTimeout':
            [PyTango.DevULong,
            "Timeout of serial port: use -1 for None (only for direct serial connection)",
            [-1]],
        'SerialXonXoff':
            [PyTango.DevBoolean,
            "Enable software flow control of serial port: use -1 for None (only for direct serial connection)",
            [False]],
        'TxTerminator':
            [PyTango.DevString,
             "Symbol to be append to the end of the scpi string send to the instrument",
             ["\n"]],
        'NumChannels':
            [PyTango.DevUShort,
            "Number of channels available in the instrument, if it has",
            [0]],
        'NumFunctions':
            [PyTango.DevUShort,
            "Number of functions available in the instrument, if it has",
            [0]],
        'NumMultiple':
            [PyTango.DevVarStringArray,
            "From the generalisation of channels and functions, a list of pairs with the 'scpiPrefix' and how many shall be build",
            [] ],
        'MonitoredAttributes':
            [PyTango.DevVarStringArray,
            "When the device is in RUNNING state, the attributes listed here will be monitored (having events) with a period said in the attribute TimeStampsThreashold (or different if specified with a : separator after the attrName)",
            [] ],
        'AutoOn':
            [PyTango.DevBoolean,
            "When device startup, try an on() to connect to the instrument authomatically",
            [True]],
        'AutoStart':
            [PyTango.DevBoolean,
            "When device startup, try an Start() to monitor attributes, if MonitoredAttributes is configuredc, authomatically",
            [True]],
        'AutoStandby':
            [PyTango.DevBoolean,
            "When device startup, try an standby() to connect to the instrument authomatically.",
            [True]],
        }


    #    Command definitions
    cmd_list = {
        'IDN':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevString, "none"]],
        'Start':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevBoolean, "none"]],
        'Stop':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevBoolean, "none"]],
        'On':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevBoolean, "none"]],
        'Off':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevBoolean, "none"]],
        'Exec':
            [[PyTango.DevString, "none"],
            [PyTango.DevString, "none"],
            {
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'AddMonitoring':
            [[PyTango.DevString, "none"],
            [PyTango.DevBoolean, "none"]],
        'RemoveMonitoring':
            [[PyTango.DevString, "none"],
            [PyTango.DevBoolean, "none"]],
        'SetMonitoringPeriod':
            [[PyTango.DevVarStringArray, "none"],
            [PyTango.DevBoolean, "none"]],
        'GetMonitoringPeriod':
            [[PyTango.DevString, "none"],
            [PyTango.DevFloat, "none"]],
        'CMD':
            [[PyTango.DevString, "none"],
            [PyTango.DevString, "none"],
            {
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'CMDfloat':
            [[PyTango.DevString, "none"],
            [PyTango.DevVarFloatArray, "none"],
            {
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'Standby':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevBoolean, "none"]],
        }


    #    Attribute definitions
    attr_list = {
        'Idn':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'description': "Instrument identification",
            } ],
        'QueryWindow':
            [[PyTango.DevUShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Query Window",
                'unit': "queries",
                'format': "%2d",
                'min value': "1",
                'max warning': "20",
                'description': "When many attributes are requested at the same time, they are grouped in subqueries of this size",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'TimeStampsThreshold':
            [[PyTango.DevFloat,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Time stamps threshold",
                'unit': "seconds",
                'format': "%3.2g",
                'max value': "3",
                'min value': "0.1",
                'description': "This value sets the threshold time to use a cached value or hardware read it",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        }


def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(SkippyClass,Skippy,'Skippy')
        #----- PROTECTED REGION ID(Skippy.add_classes) ENABLED START -----#

        #----- PROTECTED REGION END -----#  //  Skippy.add_classes

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e

if __name__ == '__main__':
    main()
